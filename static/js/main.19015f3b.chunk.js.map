{"version":3,"sources":["slip.js","SlipMove.js","App.js","array.js","index.js"],"names":["slip","transformJSPropertyName","document","createElement","style","transformCSSPropertyName","Slip","container","options","arguments","length","undefined","raised","querySelector","addEventListener","Error","this","window","cancel","setState","bind","states","idle","onTouchStart","onTouchMove","onTouchEnd","onMouseDown","onMouseMove","onMouseUp","onMouseLeave","onSelection","onContainerFocus","onContextMenu","attach","addClass","nodes","Promise","resolve","reject","i","n","classList","add","getTransform","node","transform","value","original","getComputedStyle","getPropertyValue","prototype","state","target","usingTouch","mouseHandlersAttached","startPosition","latestPosition","previousPosition","canPreventScrolling","removeMouseHandlers","willChange","allowTextSelection","undecided","_undecidedStateInit","Object","asyncToGenerator","regenerator_default","a","mark","_callee","_window$getComputedSt","marginTop","marginBottom","holdTimer","zero","_start","t","wrap","_context","prev","next","height","offsetHeight","Math","max","parseInt","dispatch","originalTarget","setTimeout","move","getAbsoluteMovement","x","y","reorder","children","offsetTop","otherNodes","Date","now","originalIndex","abrupt","push","baseTransform","pos","console","log","leaveState","clearTimeout","onMove","onLeave","onEnd","allowDefault","stop","apply","mouseOutsideTimer","_this","focus","draggingClassName","zIndex","handleMove","updateScrolling","getTotalMovement","concat","spliceIndex","getSpliceIndex","relativeIndex","forEach","o","off","curOff","replace","isNaN","requestAnimationFrame","call","animateToZero","remove","insertBefore","detach","passive","capture","removeEventListener","newStateCtor","ctor","prevState","nextState","findTargetNode","targetNode","parentNode","e","stopPropagation","isRelated","iOS","test","navigator","userAgent","preventDefault","addMouseHandlers","documentElement","relatedTarget","button","setTarget","startAtPosition","clientX","clientY","time","timeStamp","touches","scrollContainer","body","scrollHeight","clientHeight","origScrollTop","scrollTop","origScrollHeight","updatePosition","scrollOffset","abs","directionX","directionY","offset","scrollable","containerRect","getBoundingClientRect","targetRect","bottomOffset","min","bottom","innerHeight","topOffset","top","maxScrollTop","eventName","detail","event","createEvent","initCustomEvent","initEvent","dispatchEvent","callback","_this2","_target","_transformMatrix$matc","match","_transformMatrix$matc2","slicedToArray","offsetX","offsetY","transitionProperty","animateDrop","contains","transition","reordering","handleBeforeReorder","props","disableMove","onMoveStart","handleReorder","_e$detail","oldIndex","newIndex","onMoveEnd","init","elevateItem","_this$props","flipMoveProps","_this$props$style","position","react_default","id","ref","objectSpread","react_flip_move_es","assign","typeName","disableAllAnimations","Component","defaultProps","generateItems","toConsumableArray","Array","keys","map","k","actions","reverse","_ref","arr","items","slice","shuffle","_ref2","random","sort","b","_ref3","removeFrom","insertAt","Number","_arr","item","splice","_ref4","className","onClick","SlipMove_default","appearAnimation","App_ListItem","key","ListItem","PureComponent","ReactDOM","render","src_App_default","getElementById"],"mappings":"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","file":"static/js/main.19015f3b.chunk.js","sourcesContent":["/*\r\n    Slip - swiping and reordering in lists of elements on touch screens, no fuss.\r\n\r\n    Fires these events on list elements:\r\n\r\n        • slip:reorder\r\n            Element has been dropped in new location. event.detail contains the following:\r\n                • insertBefore: DOM node before which element has been dropped (null is the end of the list). Use with node.insertBefore().\r\n                • spliceIndex: Index of element before which current element has been dropped, not counting the element iself.\r\n                               For use with Array.splice() if the list is reflecting objects in some array.\r\n                • originalIndex: The original index of the element before it was reordered.\r\n\r\n        • slip:beforereorder\r\n            When reordering movement starts.\r\n            Element being reordered gets class `slip-dragging`.\r\n            If you execute event.preventDefault() then the element will not move at all.\r\n\r\n        • slip:beforewait\r\n            If you execute event.preventDefault() then reordering will begin immediately, blocking ability to scroll the page.\r\n\r\n        • slip:tap\r\n            When element was tapped without being swiped/reordered. You can check `event.target` to limit that behavior to drag handles.\r\n\r\n\r\n    Usage:\r\n\r\n        CSS:\r\n            You should set `user-select:none` (and WebKit prefixes, sigh) on list elements,\r\n            otherwise unstoppable and glitchy text selection in iOS will get in the way.\r\n\r\n        list.addEventListener('slip:beforereorder', function(e) {\r\n            if (shouldNotReorder(e.target)) e.preventDefault();\r\n        });\r\n\r\n        list.addEventListener('slip:reorder', function(e) {\r\n            // e.target reordered.\r\n            if (reorderedOK) {\r\n                e.target.parentNode.insertBefore(e.target, e.detail.insertBefore);\r\n            } else {\r\n                e.preventDefault();\r\n            }\r\n        });\r\n\r\n    Requires:\r\n        • Touch events\r\n        • CSS transforms\r\n        • Function.bind()\r\n\r\n    Caveats:\r\n        • Elements must not change size while reordering or swiping takes place (otherwise it will be visually out of sync)\r\n*/\r\n/*! @license\r\n    Slip.js 1.2.0\r\n\r\n    © 2014 Kornel Lesiński <kornel@geekhood.net>. All rights reserved.\r\n\r\n    Redistribution and use in source and binary forms, with or without modification,\r\n    are permitted provided that the following conditions are met:\r\n\r\n    1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.\r\n\r\n    2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and\r\n       the following disclaimer in the documentation and/or other materials provided with the distribution.\r\n\r\n    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES,\r\n    INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\r\n    DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\r\n    SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\r\n    SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\r\n    WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE\r\n    USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\r\n*/\r\n\r\n\r\n\r\nexport default (function(){\r\n\r\n    // -webkit-mess\r\n    const testElementStyle = document.createElement('div').style;\r\n\r\n    const transformJSPropertyName = \"transform\" in testElementStyle ? \"transform\" : \"webkitTransform\";\r\n    const transformCSSPropertyName = transformJSPropertyName === \"webkitTransform\" ? \"-webkit-transform\" : \"transform\";\r\n\r\n    function Slip(container, options = { raised: true }) {\r\n        if ('string' === typeof container) container = document.querySelector(container);\r\n        if (!container || !container.addEventListener) throw new Error(\"Please specify DOM node to attach to\");\r\n\r\n        if (!this || this === window) return new Slip(container);\r\n\r\n        this.options = options;\r\n\r\n        // Functions used for as event handlers need usable `this` and must not change to be removable\r\n        this.cancel = this.setState.bind(this, this.states.idle);\r\n        this.onTouchStart = this.onTouchStart.bind(this);\r\n        this.onTouchMove = this.onTouchMove.bind(this);\r\n        this.onTouchEnd = this.onTouchEnd.bind(this);\r\n        this.onMouseDown = this.onMouseDown.bind(this);\r\n        this.onMouseMove = this.onMouseMove.bind(this);\r\n        this.onMouseUp = this.onMouseUp.bind(this);\r\n        this.onMouseLeave = this.onMouseLeave.bind(this);\r\n        this.onSelection = this.onSelection.bind(this);\r\n        this.onContainerFocus = this.onContainerFocus.bind(this);\r\n        this.onContextMenu = this.onContextMenu.bind(this);\r\n\r\n        this.setState(this.states.idle);\r\n        this.attach(container);\r\n    }\r\n\r\n    function addClass(nodes) {\r\n        return new Promise(function(resolve, reject) {\r\n            for(let i=0, n=nodes.length; i < n; i++) {\r\n                nodes[i].classList.add('slip-transition');\r\n            }\r\n            resolve();\r\n        });\r\n    }\r\n\r\n\r\n\r\n    function getTransform(node) {\r\n        const transform = node.style[transformJSPropertyName];\r\n        if (transform) {\r\n            return {\r\n                value: transform,\r\n                original: transform,\r\n            };\r\n        }\r\n\r\n        if (window.getComputedStyle) {\r\n            const style = window.getComputedStyle(node).getPropertyValue(transformCSSPropertyName);\r\n            if (style && style !== 'none') return {value:style, original:''};\r\n        }\r\n        return {value:'', original:''};\r\n    }\r\n\r\n    // All functions in states are going to be executed in context of Slip object\r\n    Slip.prototype = {\r\n\r\n        container: null,\r\n        state: null,\r\n\r\n        target: null, // the tapped/swiped/reordered node with height and backed up styles\r\n\r\n        usingTouch: false, // there's no good way to detect touchscreen preference other than receiving a touch event (really, trust me).\r\n        mouseHandlersAttached: false,\r\n\r\n        startPosition: null, // x,y,time where first touch began\r\n        latestPosition: null, // x,y,time where the finger is currently\r\n        previousPosition: null, // x,y,time where the finger was ~100ms ago (for velocity calculation)\r\n\r\n        canPreventScrolling: false,\r\n\r\n        states: {\r\n            idle: function idleStateInit() {\r\n                this.removeMouseHandlers();\r\n                if (this.target) {\r\n                    this.target.node.style.willChange = '';\r\n                    this.target = null;\r\n                }\r\n                this.usingTouch = false;\r\n\r\n                return {\r\n                    allowTextSelection: true,\r\n                };\r\n            },\r\n\r\n            undecided: async function undecidedStateInit() {\r\n\r\n                let node = this.target.node;\r\n                const { marginTop, marginBottom } = window.getComputedStyle(node);\r\n                this.target.height = node.offsetHeight + Math.max(parseInt(marginTop), parseInt(marginBottom));\r\n                node.style.willChange = transformCSSPropertyName;\r\n                let holdTimer;\r\n                if (!this.dispatch(this.target.originalTarget, 'beforewait')) {\r\n                    if (this.dispatch(this.target.originalTarget, 'beforereorder')) {\r\n                        this.setState(this.states.reorder);\r\n                    }\r\n                } else {\r\n                    holdTimer = setTimeout(function(){\r\n                        const move = this.getAbsoluteMovement();\r\n                        if (this.canPreventScrolling && move.x < 15 && move.y < 25) {\r\n                            if (this.dispatch(this.target.originalTarget, 'beforereorder')) {\r\n                                this.setState(this.states.reorder);\r\n                            }\r\n                        }\r\n                    }.bind(this), 300);\r\n                }\r\n                const nodes = this.container.children;\r\n                const zero = node.offsetTop + this.target.height/2;\r\n                this.otherNodes = [];\r\n                const _start = Date.now();\r\n\r\n                for(let i=0, n=nodes.length; i < n; i++) {\r\n                    if (nodes[i] === node) {\r\n                        this.originalIndex = i;\r\n                        continue;\r\n                    }\r\n                    nodes[i].classList.add('slip-transition');\r\n                    const t = nodes[i].offsetTop;\r\n                    this.otherNodes.push({\r\n                        node: nodes[i],\r\n                        baseTransform: getTransform(nodes[i]),\r\n                        pos: t + (t < zero ? nodes[i].offsetHeight : 0) - zero,\r\n                    });\r\n                }\r\n                addClass(nodes);\r\n                console.log(Date.now() - _start);\r\n\r\n                return {\r\n                    leaveState: function() {\r\n                        clearTimeout(holdTimer);\r\n                    },\r\n\r\n                    onMove: function() {\r\n                        const move = this.getAbsoluteMovement();\r\n\r\n                        if (move.y > 20) {\r\n                            this.setState(this.states.idle);\r\n                        }\r\n\r\n                        // Chrome likes sideways scrolling :(\r\n                        if (move.x > move.y*1.2) return false;\r\n                    },\r\n\r\n                    onLeave: function() {\r\n                        this.setState(this.states.idle);\r\n                    },\r\n\r\n                    onEnd: function() {\r\n                        const allowDefault = this.dispatch(this.target.originalTarget, 'tap');\r\n                        this.setState(this.states.idle);\r\n                        return allowDefault;\r\n                    },\r\n                };\r\n            },\r\n\r\n            reorder: function reorderStateInit() {\r\n                let node = this.target.node;\r\n                node.focus && node.focus();\r\n\r\n                // const { marginTop, marginBottom } = window.getComputedStyle(node);\r\n                // this.target.height = node.offsetHeight + Math.max(parseInt(marginTop), parseInt(marginBottom));\r\n\r\n                // const nodes = this.container.children;\r\n                // let originalIndex;\r\n                // const zero = node.offsetTop + this.target.height/2;\r\n                // const this.otherNodes = [];\r\n                // const start = Date.now();\r\n                // for(let i=0, n=nodes.length; i < n; i++) {\r\n                //     if (nodes[i] === node) {\r\n                //         originalIndex = i;\r\n                //         continue;\r\n                //     }\r\n                //     nodes[i].classList.add('slip-transition');\r\n                //     const t = nodes[i].offsetTop;\r\n                //     this.otherNodes.push({\r\n                //         node: nodes[i],\r\n                //         baseTransform: getTransform(nodes[i]),\r\n                //         pos: t + (t < zero ? nodes[i].offsetHeight : 0) - zero,\r\n                //     });\r\n                // }\r\n                // console.log(Date.now() - start);\r\n                // const nodesArray = Array.prototype.slice.call(nodes);\r\n                // console.log(nodesArray.map(n => n.style.willChange));\r\n                node.classList.add('slip-dragging');\r\n                if (this.options.draggingClassName)\r\n                    node.classList.add(this.options.draggingClassName);\r\n                if (this.options.raised)\r\n                    node.classList.add('slip-shadow');\r\n                node.style.zIndex = '99999';\r\n\r\n                let mouseOutsideTimer;\r\n\r\n\r\n                const getSpliceIndex = (move) => {\r\n                    let i, spliceIndex;\r\n\r\n                    if (move.y < 0) {\r\n                        for (i=0; i < this.otherNodes.length; i++) {\r\n                            if (this.otherNodes[i].pos > move.y) {\r\n                                break;\r\n                            }\r\n                        }\r\n                        spliceIndex = i;\r\n                    } else {\r\n                        for (i=this.otherNodes.length-1; i >= 0; i--) {\r\n                            if (this.otherNodes[i].pos < move.y) {\r\n                                break;\r\n                            }\r\n                        }\r\n                        spliceIndex = i+1;\r\n                    }\r\n                    // this.target.relativeIndex = spliceIndex - originalIndex;\r\n                    // console.log(this.target.relativeIndex);\r\n                    return spliceIndex;\r\n                }\r\n\r\n                const handleMove = () => {\r\n                    if (!this.target) return;\r\n                    this.updateScrolling();\r\n\r\n                    if (mouseOutsideTimer) {\r\n                        // don't care where the mouse is as long as it moves\r\n                        clearTimeout(mouseOutsideTimer); mouseOutsideTimer = null;\r\n                    }\r\n\r\n                    const move = this.getTotalMovement();\r\n                    this.target.node.style[transformJSPropertyName] = `translate(${move.x}px,${move.y}px) ` + this.target.baseTransform.value;\r\n\r\n\r\n                    const spliceIndex = getSpliceIndex(move);\r\n                    const relativeIndex = spliceIndex - this.originalIndex;\r\n                    if (this.target.relativeIndex === undefined)\r\n                        this.target.relativeIndex = relativeIndex;\r\n                    // console.log(this.target.node.style.transform, window.getComputedStyle(this.target.node)['transition']);\r\n                    if (relativeIndex !== this.target.relativeIndex) {\r\n                        const height = this.target.height; // +2 for margin\r\n                        this.otherNodes.forEach((o, i) => {\r\n                            let off = 0;\r\n                            if (o.pos < 0 && move.y < 0 && o.pos > move.y) {\r\n                                off = height;\r\n                            }\r\n                            else if (o.pos > 0 && move.y > 0 && o.pos < move.y) {\r\n                                off = -height;\r\n                            }\r\n                            // FIXME: should change accelerated/non-accelerated state lazily\r\n                            let curOff = parseInt(o.node.style.transform.replace('translateY(', ''));\r\n                            if (isNaN(curOff)) {\r\n                                curOff = 0;\r\n                            }\r\n                            // console.log(o.node.innerText, o.node.style.transform, off, curOff, off !== curOff, i - this.originalIndex);\r\n                            if (off !== curOff) {\r\n                                o.node.style[transformJSPropertyName] = off ? `translateY(${off}px) ` + o.baseTransform.value : o.baseTransform.original;\r\n                            }\r\n                        });\r\n                    }\r\n                    this.target.relativeIndex = relativeIndex;\r\n                    this.target.spliceIndex = spliceIndex;\r\n\r\n                    // console.log('----------------');\r\n                };\r\n\r\n                function onMove() {\r\n\r\n                        /*jshint validthis:true */\r\n                    requestAnimationFrame(handleMove);\r\n                    return false;\r\n                }\r\n\r\n                onMove.call(this);\r\n\r\n                // console.log(Date.now() - start);\r\n                return {\r\n                    leaveState: function() {\r\n                        if (mouseOutsideTimer) clearTimeout(mouseOutsideTimer);\r\n\r\n                        if (this.container.focus) {\r\n                            this.container.focus();\r\n                        }\r\n\r\n                        this.animateToZero(function(target){\r\n                            target.node.style.zIndex = '';\r\n                        });\r\n                        this.otherNodes.forEach(function(o){\r\n                            o.node.style[transformJSPropertyName] = o.baseTransform.original;\r\n                            o.node.style.willChange = null;\r\n                            o.node.classList.remove('slip-transition');\r\n                        });\r\n                    },\r\n\r\n                    onMove: onMove,\r\n\r\n                    onLeave: function() {\r\n                        // don't let element get stuck if mouse left the window\r\n                        // but don't cancel immediately as it'd be annoying near window edges\r\n                        if (mouseOutsideTimer) clearTimeout(mouseOutsideTimer);\r\n                        mouseOutsideTimer = setTimeout(function(){\r\n                            mouseOutsideTimer = null;\r\n                            this.cancel();\r\n                        }.bind(this), 700);\r\n                    },\r\n\r\n                    onEnd: function() {\r\n                        const {spliceIndex} = this.target;\r\n                        this.dispatch(this.target.node, 'reorder', {\r\n                            spliceIndex,\r\n                            originalIndex: this.originalIndex,\r\n                            insertBefore: this.otherNodes[spliceIndex] ? this.otherNodes[spliceIndex].node : null,\r\n                        });\r\n                        this.setState(this.states.idle);\r\n                        return false;\r\n                    },\r\n                };\r\n            },\r\n        },\r\n\r\n        attach: function(container) {\r\n            if (this.container) this.detach();\r\n\r\n            this.container = container;\r\n\r\n            this.container.addEventListener('focus', this.onContainerFocus, {passive:true, capture: false});\r\n\r\n            this.otherNodes = [];\r\n\r\n            // selection on iOS interferes with reordering\r\n            document.addEventListener(\"selectionchange\", this.onSelection, {passive:false, capture: false});\r\n\r\n            // cancel is called e.g. when iOS detects multitasking gesture\r\n            this.container.addEventListener('touchcancel', this.cancel, {passive:true, capture: false});\r\n            this.container.addEventListener('touchstart', this.onTouchStart, {passive:true, capture: false});\r\n            this.container.addEventListener('touchmove', this.onTouchMove, {passive:false, capture: false});\r\n            this.container.addEventListener('touchend', this.onTouchEnd, {passive:false, capture: false});\r\n            this.container.addEventListener('mousedown', this.onMouseDown, {passive:true, capture: false});\r\n            this.container.addEventListener('contextmenu', this.onContextMenu, {passive:false, capture: false});\r\n            // mousemove and mouseup are attached dynamically\r\n        },\r\n\r\n        detach: function() {\r\n            this.cancel();\r\n\r\n            this.container.removeEventListener('mousedown', this.onMouseDown, {passive:true, capture: false});\r\n            this.container.removeEventListener('touchend', this.onTouchEnd, {passive:false, capture: false});\r\n            this.container.removeEventListener('touchmove', this.onTouchMove, {passive:false, capture: false});\r\n            this.container.removeEventListener('touchstart', this.onTouchStart, {passive:true, capture: false});\r\n            this.container.removeEventListener('touchcancel', this.cancel, {passive:true, capture: false});\r\n            this.container.removeEventListener('contextmenu', this.onContextMenu, {passive:true, capture: false});\r\n\r\n            document.removeEventListener(\"selectionchange\", this.onSelection, {passive:false, capture: false});\r\n\r\n        },\r\n\r\n        setState: function(newStateCtor){\r\n            if (this.state) {\r\n                if (this.state.ctor === newStateCtor) return;\r\n                if (this.state.leaveState) this.state.leaveState.call(this);\r\n            }\r\n\r\n            // Must be re-entrant in case ctor changes state\r\n            const prevState = this.state;\r\n            let nextState = newStateCtor.call(this);\r\n            if (this.state === prevState) {\r\n                nextState.ctor = newStateCtor;\r\n                this.state = nextState;\r\n            }\r\n        },\r\n\r\n        findTargetNode: function(targetNode) {\r\n            while(targetNode && targetNode.parentNode !== this.container) {\r\n                targetNode = targetNode.parentNode;\r\n            }\r\n            return targetNode;\r\n        },\r\n\r\n        onContainerFocus: function(e) {\r\n            e.stopPropagation();\r\n        },\r\n\r\n        onSelection: function(e) {\r\n            e.stopPropagation();\r\n            const isRelated = e.target === document || this.findTargetNode(e);\r\n            const iOS = /(iPhone|iPad|iPod)/i.test(navigator.userAgent) && !/(Android|Windows)/i.test(navigator.userAgent);\r\n            if (!isRelated) return;\r\n\r\n            if (iOS) {\r\n                // iOS doesn't allow selection to be prevented\r\n                this.setState(this.states.idle);\r\n            } else {\r\n                if (!this.state.allowTextSelection) {\r\n                    e.preventDefault();\r\n                }\r\n            }\r\n        },\r\n\r\n        addMouseHandlers: function() {\r\n            // unlike touch events, mousemove/up is not conveniently fired on the same element,\r\n            // but I don't need to listen to unrelated events all the time\r\n            if (!this.mouseHandlersAttached) {\r\n                this.mouseHandlersAttached = true;\r\n                document.documentElement.addEventListener('mouseleave', this.onMouseLeave, {passive:true, capture: false});\r\n                window.addEventListener('mousemove', this.onMouseMove, {passive:false, capture: true});\r\n                window.addEventListener('mouseup', this.onMouseUp, {passive:false, capture: true});\r\n                window.addEventListener('blur', this.cancel, {passive:true, capture: false});\r\n            }\r\n        },\r\n\r\n        removeMouseHandlers: function() {\r\n            if (this.mouseHandlersAttached) {\r\n                this.mouseHandlersAttached = false;\r\n                document.documentElement.removeEventListener('mouseleave', this.onMouseLeave, {passive:true, capture: false});\r\n                window.removeEventListener('mousemove', this.onMouseMove, {passive:false, capture: true});\r\n                window.removeEventListener('mouseup', this.onMouseUp, {passive:false, capture: true});\r\n                window.removeEventListener('blur', this.cancel, {passive:true, capture: false});\r\n            }\r\n        },\r\n\r\n        onMouseLeave: function(e) {\r\n            e.stopPropagation();\r\n            if (this.usingTouch) return;\r\n\r\n            if (e.target === document.documentElement || e.relatedTarget === document.documentElement) {\r\n                if (this.state.onLeave) {\r\n                    this.state.onLeave.call(this);\r\n                }\r\n            }\r\n        },\r\n\r\n        onMouseDown: function(e) {\r\n            e.stopPropagation();\r\n            if (this.usingTouch || e.button !== 0 || !this.setTarget(e)) return;\r\n\r\n            this.addMouseHandlers(); // mouseup, etc.\r\n\r\n            this.canPreventScrolling = true; // or rather it doesn't apply to mouse\r\n\r\n            this.startAtPosition({\r\n                x: e.clientX,\r\n                y: e.clientY,\r\n                time: e.timeStamp,\r\n            });\r\n        },\r\n\r\n        onTouchStart: function(e) {\r\n            e.stopPropagation();\r\n            this.usingTouch = true;\r\n            this.canPreventScrolling = true;\r\n\r\n            // This implementation cares only about single touch\r\n            if (e.touches.length > 1) {\r\n                this.setState(this.states.idle);\r\n                return;\r\n            }\r\n\r\n            if (!this.setTarget(e)) return;\r\n\r\n            this.startAtPosition({\r\n                x: e.touches[0].clientX,\r\n                y: e.touches[0].clientY,\r\n                time: e.timeStamp,\r\n            });\r\n        },\r\n\r\n        setTarget: function(e) {\r\n            const targetNode = this.findTargetNode(e.target);\r\n            if (!targetNode) {\r\n                this.setState(this.states.idle);\r\n                return false;\r\n            }\r\n\r\n            //check for a scrollable parent\r\n            let scrollContainer = targetNode.parentNode;\r\n            while (scrollContainer) {\r\n                if (scrollContainer === document.body) break;\r\n                if (scrollContainer.scrollHeight > scrollContainer.clientHeight && window.getComputedStyle(scrollContainer)['overflow-y'] !== 'visible') break;\r\n                scrollContainer = scrollContainer.parentNode;\r\n            }\r\n            scrollContainer = scrollContainer || document.body;\r\n\r\n            this.target = {\r\n                originalTarget: e.target,\r\n                node: targetNode,\r\n                scrollContainer: scrollContainer,\r\n                origScrollTop: scrollContainer.scrollTop,\r\n                origScrollHeight: scrollContainer.scrollHeight,\r\n                baseTransform: getTransform(targetNode),\r\n            };\r\n            return true;\r\n        },\r\n\r\n        startAtPosition: function(pos) {\r\n            this.startPosition = this.previousPosition = this.latestPosition = pos;\r\n            this.setState(this.states.undecided);\r\n        },\r\n\r\n        updatePosition: function(e, pos) {\r\n            if (this.target == null) {\r\n                return;\r\n            }\r\n            this.latestPosition = pos;\r\n\r\n            if (this.state.onMove) {\r\n                if (this.state.onMove.call(this) === false) {\r\n                    e.preventDefault();\r\n                }\r\n            }\r\n\r\n            // sample latestPosition 100ms for velocity\r\n            if (this.latestPosition.time - this.previousPosition.time > 100) {\r\n                this.previousPosition = this.latestPosition;\r\n            }\r\n        },\r\n\r\n        onMouseMove: function(e) {\r\n            e.stopPropagation();\r\n            this.updatePosition(e, {\r\n                x: e.clientX,\r\n                y: e.clientY,\r\n                time: e.timeStamp,\r\n            });\r\n        },\r\n\r\n        onTouchMove: function(e) {\r\n            e.stopPropagation();\r\n            this.updatePosition(e, {\r\n                x: e.touches[0].clientX,\r\n                y: e.touches[0].clientY,\r\n                time: e.timeStamp,\r\n            });\r\n\r\n            // In Apple's touch model only the first move event after touchstart can prevent scrolling (and event.cancelable is broken)\r\n            this.canPreventScrolling = false;\r\n        },\r\n\r\n        onMouseUp: function(e) {\r\n            e.stopPropagation();\r\n            if (this.usingTouch || e.button !== 0) return;\r\n\r\n            if (this.state.onEnd && false === this.state.onEnd.call(this)) {\r\n                e.preventDefault();\r\n            }\r\n        },\r\n\r\n        onTouchEnd: function(e) {\r\n            e.stopPropagation();\r\n            if (e.touches.length > 1) {\r\n                this.cancel();\r\n            } else if (this.state.onEnd && false === this.state.onEnd.call(this)) {\r\n                e.preventDefault();\r\n            }\r\n        },\r\n\r\n        onContextMenu: function(e) {\r\n            e.preventDefault();\r\n            e.stopPropagation();\r\n        },\r\n\r\n        getTotalMovement: function() {\r\n            if (!this.target) return;\r\n            const scrollOffset = this.target.scrollContainer.scrollTop - this.target.origScrollTop;\r\n            return {\r\n                x: this.latestPosition.x - this.startPosition.x,\r\n                y: this.latestPosition.y - this.startPosition.y + scrollOffset,\r\n                time: this.latestPosition.time - this.startPosition.time,\r\n            };\r\n        },\r\n\r\n        getAbsoluteMovement: function() {\r\n            const move = this.getTotalMovement();\r\n            return {\r\n                x: Math.abs(move.x),\r\n                y: Math.abs(move.y),\r\n                time: move.time,\r\n                directionX: move.x < 0 ? 'left' : 'right',\r\n                directionY: move.y < 0 ? 'up' : 'down',\r\n            };\r\n        },\r\n\r\n        updateScrolling: function() {\r\n            let triggerOffset = 40,\r\n                offset = 0;\r\n\r\n            const scrollable = this.target.scrollContainer,\r\n                containerRect = scrollable.getBoundingClientRect(),\r\n                targetRect = this.target.node.getBoundingClientRect(),\r\n                bottomOffset = Math.min(containerRect.bottom, window.innerHeight) - targetRect.bottom,\r\n                topOffset = targetRect.top - Math.max(containerRect.top, 0),\r\n                maxScrollTop = this.target.origScrollHeight - Math.min(scrollable.clientHeight, window.innerHeight);\r\n\r\n            if (bottomOffset < triggerOffset) {\r\n              offset = Math.min(triggerOffset, triggerOffset - bottomOffset);\r\n            }\r\n            else if (topOffset < triggerOffset) {\r\n              offset = Math.max(-triggerOffset, topOffset - triggerOffset);\r\n            }\r\n\r\n            scrollable.scrollTop = Math.max(0, Math.min(maxScrollTop, scrollable.scrollTop + offset));\r\n        },\r\n\r\n        dispatch: function(targetNode, eventName, detail) {\r\n            let event = document.createEvent('CustomEvent');\r\n            if (event && event.initCustomEvent) {\r\n                event.initCustomEvent('slip:' + eventName, true, true, detail);\r\n            } else {\r\n                event = document.createEvent('Event');\r\n                event.initEvent('slip:' + eventName, true, true);\r\n                event.detail = detail;\r\n            }\r\n            return targetNode.dispatchEvent(event);\r\n        },\r\n\r\n        animateToZero: function(callback, target) {\r\n            // save, because this.target/container could change during animation\r\n            target = target || this.target;\r\n\r\n            const { node, height, relativeIndex } = target;\r\n            const transformMatrix = window.getComputedStyle(node).getPropertyValue(transformJSPropertyName);\r\n            const [,,,,translateX, translateY] = transformMatrix.match(/-?\\d+/g);\r\n            // const translateY = parseInt(window.getComputedStyle(node).getPropertyValue(transformJSPropertyName).split(\",\")[5]);\r\n            const [offsetX, offsetY] = [translateX, translateY - height * relativeIndex];\r\n\r\n            // By now item has moved to new location. Translate instantly to new position maintaining drag offset\r\n            node.style[transformJSPropertyName] = `translate(${offsetX}px,${offsetY}px)`\r\n\r\n            // After translate, animate smoothly into place from offset\r\n            setTimeout((node) => {\r\n                node.style.transitionProperty = 'all';\r\n                node.style[transformJSPropertyName] = target.baseTransform.original;\r\n                const animateDrop = e =>  {\r\n                    if (node.classList.contains('slip-dragging')) {\r\n                        node.classList.remove(this.options.draggingClassName);\r\n                        node.classList.remove('slip-dragging');\r\n                        node.classList.remove('slip-shadow');\r\n                        node.classList.add('slip-dropping');\r\n                    }\r\n                    else {\r\n                        if (node.classList.contains('slip-dropping')) {\r\n                            node.removeEventListener(\"transitionend\", animateDrop, false);\r\n                            node.classList.remove('slip-dropping');\r\n                            node.style.transition='';\r\n                            if (callback) callback.call(this, target);\r\n                        }\r\n                    }\r\n\r\n                }\r\n                node.addEventListener(\"transitionend\", animateDrop, false);\r\n            },0, node);\r\n        },\r\n    };\r\n\r\n    return Slip;\r\n})();\r\n","import React, { Component } from 'react';\r\nimport PropTypes from 'prop-types';\r\nimport Slip from './slip';\r\nimport FlipMove from 'react-flip-move';\r\nimport './slip.css';\r\n\r\nexport default class extends Component {\r\n\r\n  static propTypes = {\r\n    children: PropTypes.array,\r\n    onMove: PropTypes.func,\r\n    onMoveStart: PropTypes.func,\r\n    disableMove: PropTypes.bool,\r\n    flipMoveProps: PropTypes.object,\r\n    elevateItem: PropTypes.bool,\r\n    style: PropTypes.object\r\n  };\r\n\r\n  static defaultProps = {\r\n    elevateItem: true\r\n  }\r\n\r\n  state = {\r\n    reordering: false\r\n  }\r\n  \r\n  handleBeforeReorder = e => {\r\n    if (this.props.disableMove) {\r\n        e.preventDefault();\r\n        return;\r\n    }\r\n    this.setState({reordering: true});\r\n    this.props.onMoveStart && this.props.onMoveStart();\r\n  }\r\n\r\n  handleReorder = e => {\r\n    const { originalIndex: oldIndex, spliceIndex: newIndex } = e.detail;\r\n    this.props.onMoveEnd && this.props.onMoveEnd({oldIndex, newIndex});\r\n    this.setState({reordering:false});\r\n  }\r\n\r\n  container = null;\r\n  init = node => {\r\n    this.container = node;\r\n    new Slip(this.container, { raised: this.props.elevateItem, draggingClassName: 'slipmove-dragging' });\r\n    this.container.addEventListener('slip:beforereorder', this.handleBeforeReorder);\r\n    this.container.addEventListener('slip:reorder', this.handleReorder);    \r\n  }\r\n\r\n  componentWillUnmount() {\r\n    this.container.removeEventListener('slip:beforereorder', this.handleBeforeReorder);\r\n    this.container.removeEventListener('slip:reorder', this.handleReorder);    \r\n  }\r\n\r\n  render() {\r\n    const { children, flipMoveProps, style = {} } = this.props;\r\n    /*\r\n        'Wrapperless' FlipMove is used here to pass container props down but it requires a\r\n        non static position => override if static or not defined (css defaults to static). \r\n        (FlipMove overrides it anyway but shows a console warning.)\r\n    */\r\n    if ((style.position || 'static') === 'static') style.position = 'relative'; \r\n    \r\n    return (\r\n        <div id=\"container\" ref={this.init} style={{...style}}>\r\n            <FlipMove typeName={null} { ...flipMoveProps } disableAllAnimations={this.state.reordering} >\r\n                {children}\r\n            </FlipMove>\r\n        </div>\r\n    );\r\n  }\r\n}\r\n\r\n","import React, { Component, PureComponent } from 'react';\r\nimport SlipMove from './SlipMove';\r\nimport './App.css';\r\nimport { move, shuffle, reverse } from './array';\r\n\r\nconst generateItems = length => [...Array(length).keys()].map(k => `Item ${k}`)\r\n\r\nconst actions = {\r\n  reverse: ({items}) => ({items: reverse(items)}),\r\n  shuffle: ({items}) => ({items: shuffle(items)}),\r\n  move: (oldIndex, newIndex) => ({items}) => ({items: move(items, oldIndex, newIndex)}),\r\n}\r\n\r\nexport default class extends Component {\r\n\r\n  state = { items: generateItems(500) }\r\n  \r\n  move = ({oldIndex, newIndex}) => this.setState(actions.move(oldIndex, newIndex));\r\n  reverse = () => this.setState(actions.reverse);\r\n  shuffle = () => this.setState(actions.shuffle);\r\n\r\n  render() {\r\n    const { items } = this.state;\r\n    return (\r\n      <div className=\"App\" >\r\n        <button onClick={this.reverse}>Reverse</button>\r\n        <button onClick={this.shuffle}>Shuffle</button>\r\n        <SlipMove onMoveEnd={this.move} flipMoveProps={{appearAnimation: 'fade'}} >\r\n          {items.map(item => <ListItem key={item}>{item}</ListItem>)}\r\n        </SlipMove>\r\n      </div>\r\n    );\r\n  }\r\n}\r\n\r\n// FlipMove requires class compoonents as children\r\nclass ListItem extends PureComponent {\r\n  render() {\r\n    const { children } = this.props;\r\n    return <div className=\"list-item\" >{children}</div>\r\n  }\r\n}\r\n","export const move = (arr, removeFrom=null, insertAt=null) => {\r\n    /*\r\n        Adds item if removeFrom is null\r\n        Removes item if insertAt is null\r\n    */\r\n    if (insertAt === removeFrom) return arr;\r\n    if (isNaN(Number(removeFrom) || isNaN(Number(insertAt)))) return arr;\r\n\r\n    let _arr = [...arr];\r\n\r\n    const item = (removeFrom !== null) ? _arr.splice(removeFrom, 1)[0] : null; \r\n    if (insertAt !== null) {\r\n        _arr.splice(insertAt, 0, item);\r\n    }\r\n\r\n    return _arr;\r\n  };\r\n    \r\nexport const shuffle = arr => arr\r\n    .map(a => [Math.random(), a])\r\n    .sort((a, b) => a[0] - b[0])\r\n    .map(a => a[1]);\r\n\r\nexport const reverse = arr => arr.slice().reverse();","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport App from './App';\n\nReactDOM.render(<App />, document.getElementById('root'));\n"],"sourceRoot":""}